// Pei Wang's "Non-Axiomatic Logic" specified with a math. notation inspired DSL: (TODO: So far only NAL1-6)

// revision (already handled by belief management in java)
//    A, A |- A, (Truth:Revision)

//// immediate inference

    (S --> P), S |- (P --> S), (Truth:Conversion)
    (S --> P), P |- (P --> S), (Truth:Conversion)
    (S ==> P), S |- (P ==> S), (Truth:Conversion)
    (S ==> P), P |- (P ==> S), (Truth:Conversion)
    (S =|> P), S |- (P =|> S), (Truth:Conversion)
    (S =|> P), P |- (P =|> S), (Truth:Conversion)
    (S =/> P), S |- (P =\> S), (Truth:Conversion)
    (S =/> P), P |- (P =\> S), (Truth:Conversion)
    (S =\> P), S |- (P =/> S), (Truth:Conversion)
    (S =\> P), P |- (P =/> S), (Truth:Conversion)

    ( --S ==> P), P |- ( --P ==> S), (Truth:Contraposition)
    ( --S ==> P), S |- ( --P ==> S), (Truth:Contraposition)
    ( --S =|> P), P |- ( --P =|> S), (Truth:Contraposition)
    ( --S =|> P), S |- ( --P =|> S), (Truth:Contraposition)
    ( --S =/> P), P |- ( --P =\> S), (Truth:Contraposition)
    ( --S =/> P), S |- ( --P =\> S), (Truth:Contraposition)
    ( --S =\> P), P |- ( --P =/> S), (Truth:Contraposition)
    ( --S =\> P), S |- ( --P =/> S), (Truth:Contraposition)

    --S, negative(--S) |- S, (Truth:Negation, Desire:Negation)
    S, negative(S) |- --S, (Truth:Negation, Desire:Negation)

//// structural inference
//java

//// inheritance-based syllogism

    (M --> P), (S --> M), not_equal(S,P) |- (S --> P), (Truth:Deduction, Desire:Strong)
    (P --> M), (S --> M), not_equal(S,P) |- (S --> P), (Truth:Abduction, Desire:Weak)
    (M --> P), (M --> S), not_equal(S,P) |- (S --> P), (Truth:Induction, Desire:Weak)
    (P --> M), (M --> S), not_equal(S,P) |- (S --> P), (Truth:Exemplification, Desire:Weak)

//// similarity from inheritance

    (S --> P), (P --> S) |- (S <-> P), (Truth:Intersection, Desire:Strong)

//// similarity-based syllogism

    (P --> M), (S --> M), not_equal(S,P) |- (S <-> P), (Truth:Comparison, Desire:Weak)
    (M --> P), (M --> S), not_equal(S,P) |- (S <-> P), (Truth:Comparison, Desire:Weak)
    (M --> P), (S <-> M), not_equal(S,P) |- (S --> P), (Truth:Analogy, Desire:Strong)
    (P --> M), (S <-> M), not_equal(S,P) |- (P --> S), (Truth:Analogy, Desire:Strong)
    (M <-> P), (S <-> M), not_equal(S,P) |- (S <-> P), (Truth:Resemblance, Desire:Strong)

//// inheritance-based composition

    (P --> M), (S --> M), not_equal(S,P), no_common_subterm(S,P) |- ((S | P) --> M), (Truth:Intersection),
                                                                    ((S & P) --> M), (Truth:Union),
                                                                    ((P ~ S) --> M), (Truth:Difference)

    (M --> P), (M --> S), not_equal(S,P), no_common_subterm(S,P) |- (M --> (P & S)), (Truth:Intersection),
                                                                    (M --> (P | S)), (Truth:Union),
                                                                    (M --> (P - S)), (Truth:Difference)

//// inheritance-based decomposition

    (S --> M), ((|,S,A_1..n) --> M) |- ((|,A_1..n) --> M), (Truth:DecomposePositiveNegativeNegative)
    (S --> M), ((&,S,A_1..n) --> M) |- ((&,A_1..n) --> M), (Truth:DecomposeNegativePositivePositive)
    (S --> M), ((~,S,P) --> M) |- (P --> M), (Truth:DecomposePositiveNegativePositive)
    (S --> M), ((~,P,S) --> M) |- (P --> M), (Truth:DecomposeNegativeNegativeNegative)

    (M --> S), (M --> (&,S,A_1..n)) |- (M --> (&,A_1..n)), (Truth:DecomposePositiveNegativeNegative)
    (M --> S), (M --> (|,S,A_1..n)) |- (M --> (|,A_1..n)), (Truth:DecomposeNegativePositivePositive)
    (M --> S), (M --> (-,S,P)) |- (M --> P), (Truth:DecomposePositiveNegativePositive)
    (M --> S), (M --> (-,P,S)) |- (M --> P), (Truth:DecomposeNegativeNegativeNegative)

//// implication-based syllogism

    (M ==> P), (S ==> M), not_equal(S,P) |- (S ==> P), (Truth:Deduction, Order:ForAllSame)
    
//"Please note that the temporal order in the conclusion of a weak rule is
//not necessarily the same as the order in the premises, given the hypothetical
//nature of such a rule."

    (P ==> M), (S ==> M), not_equal(S,P) |- (S ==> P), (Truth:Abduction)
    (P =|> M), (S =|> M), not_equal(S,P) |- (S =|> P), (Truth:Abduction),
                                            (S =/> P), (Truth:Abduction),
                                            (S =\> P), (Truth:Abduction)
    (P =/> M), (S =/> M), not_equal(S,P) |- (S =|> P), (Truth:Abduction),
                                            (S =/> P), (Truth:Abduction),
                                            (S =\> P), (Truth:Abduction)
    (P =\> M), (S =\> M), not_equal(S,P) |- (S =|> P), (Truth:Abduction),
                                            (S =/> P), (Truth:Abduction),
                                            (S =\> P), (Truth:Abduction)

    (M ==> P), (M ==> S), not_equal(S,P) |- (S ==> P), (Truth:Induction)
    (M =/> P), (M =/> S), not_equal(S,P) |- (S =|> P), (Truth:Induction),
                                            (S =/> P), (Truth:Induction),
                                            (S =\> P), (Truth:Induction)
    (M =|> P), (M =|> S), not_equal(S,P) |- (S =|> P), (Truth:Induction),
                                            (S =/> P), (Truth:Induction),
                                            (S =\> P), (Truth:Induction)
    (M =\> P), (M =\> S), not_equal(S,P) |- (S =|> P), (Truth:Induction),
                                            (S =/> P), (Truth:Induction),
                                            (S =\> P), (Truth:Induction)

    (P ==> M), (M ==> S), not_equal(S,P) |- (S ==> P), (Truth:Exemplification)
    (P =/> M), (M =/> S), not_equal(S,P) |- (S =\> P), (Truth:Exemplification)
    (P =|> M), (M =|> S), not_equal(S,P) |- (S =|> P), (Truth:Exemplification)

//// implication to equivalence

    (S ==> P), (P ==> S), not_equal(S,P) |- (S <=> P), (Truth:Intersection)
    (S =|> P), (P =|> S), not_equal(S,P) |- (S <|> P), (Truth:Intersection)
    (S =/> P), (P =\> S), not_equal(S,P) |- (S </> P), (Truth:Intersection)
    (S =\> P), (P =/> S), not_equal(S,P) |- (P </> S), (Truth:Intersection)

//// equivalence-based syllogism

    (P ==> M), (S ==> M), not_equal(S,P) |- (S <=> P), (Truth:Comparison)
    (P =/> M), (S =/> M), not_equal(S,P) |- (S <|> P), (Truth:Comparison),
                                            (S </> P), (Truth:Comparison),
                                            (P </> S), (Truth:Comparison)
    (P =|> M), (S =|> M), not_equal(S,P) |- (S <|> P), (Truth:Comparison)
    (P =\> M), (S =\> M), not_equal(S,P) |- (S <|> P), (Truth:Comparison),
                                            (S </> P), (Truth:Comparison),
                                            (P </> S), (Truth:Comparison)

    (M ==> P), (M ==> S), not_equal(S,P) |- (S <=> P), (Truth:Comparison)
    (M =/> P), (M =/> S), not_equal(S,P) |- (S <|> P), (Truth:Comparison),
                                            (S </> P), (Truth:Comparison),
                                            (P </> S), (Truth:Comparison)
    (M =|> P), (M =|> S), not_equal(S,P) |- (S <|> P), (Truth:Comparison)

    (M ==> P), (S <=> M), not_equal(S,P) |- (S ==> P), (Truth:Analogy)
    (M =/> P), (S </> M), not_equal(S,P) |- (S =/> P), (Truth:Analogy)
    (M =/> P), (S <|> M), not_equal(S,P) |- (S =/> P), (Truth:Analogy)
    (M =|> P), (S <|> M), not_equal(S,P) |- (S =|> P), (Truth:Analogy)
    (M =\> P), (M </> S), not_equal(S,P) |- (S =\> P), (Truth:Analogy)
    (M =\> P), (S <|> M), not_equal(S,P) |- (S =\> P), (Truth:Analogy)

    (P ==> M), (S <=> M), not_equal(S,P) |- (P ==> S), (Truth:Analogy)
    (P =/> M), (S <|> M), not_equal(S,P) |- (P =/> S), (Truth:Analogy)
    (P =|> M), (S <|> M), not_equal(S,P) |- (P =|> S), (Truth:Analogy)
    (P =\> M), (S </> M), not_equal(S,P) |- (P =\> S), (Truth:Analogy)
    (P =\> M), (S <|> M), not_equal(S,P) |- (P =\> S), (Truth:Analogy)

    (M <=> P), (S <=> M), not_equal(S,P) |- (S <=> P), (Truth:Resemblance)
    (M <|> P), (S <|> M), not_equal(S,P) |- (S <|> P), (Truth:Resemblance)
    (M </> P), (S </> M), not_equal(S,P) |- (S </> P), (Truth:Resemblance)
    (M </> P), (S <|> M), not_equal(S,P) |- (S </> P), (Truth:Resemblance)
    (M <|> P), (S </> M), not_equal(S,P) |- (S </> P), (Truth:Resemblance)

//// implication-based composition

    (P ==> M), (S ==> M), not_equal(S,P), no_common_subterm(S,P) |- ((P || S) ==> M), (Truth:Intersection),
                                                                    ((P && S) ==> M), (Truth:Union)
    (P =|> M), (S =|> M), not_equal(S,P), no_common_subterm(S,P) |- ((P || S) =|> M), (Truth:Intersection),
                                                                    ((P && S) =|> M), (Truth:Union)
    (P =/> M), (S =/> M), not_equal(S,P), no_common_subterm(S,P) |- ((P || S) =/> M), (Truth:Intersection),
                                                                    ((P && S) =/> M), (Truth:Union)
    (P =\> M), (S =\> M), not_equal(S,P), no_common_subterm(S,P) |- ((P || S) =\> M), (Truth:Intersection),
                                                                    ((P && S) =\> M), (Truth:Union)

    (M ==> P), (M ==> S), not_equal(S,P), no_common_subterm(S,P) |- (M ==> (P && S)), (Truth:Intersection),
                                                                    (M ==> (P || S)), (Truth:Union)
    (M =/> P), (M =/> S), not_equal(S,P), no_common_subterm(S,P) |- (M =/> (P && S)), (Truth:Intersection),
                                                                    (M =/> (P || S)), (Truth:Union)
    (M =|> P), (M =|> S), not_equal(S,P), no_common_subterm(S,P) |- (M =|> (P && S)), (Truth:Intersection),
                                                                    (M =|> (P || S)), (Truth:Union)
    (M =\> P), (M =\> S), not_equal(S,P), no_common_subterm(S,P) |- (M =\> (P && S)), (Truth:Intersection),
                                                                    (M =\> (P || S)), (Truth:Union)

//// implication-based decomposition

    (S ==> M), ((||,S,A_1..n) ==> M) |- ((||,A_1..n) ==> M), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame)

    (S ==> M), ((&&,S,A_1..n) ==> M) |- ((&&,A_1..n) ==> M), (Truth:DecomposeNegativePositivePositive, Order:ForAllSame)

    (M ==> S), (M ==> (&&,S,A_1..n)) |- (M ==> (&&,A_1..n)), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame)

    (M ==> S), (M ==> (||,S,A_1..n)) |- (M ==> (||,A_1..n)), (Truth:DecomposeNegativePositivePositive, Order:ForAllSame)

//// conditional syllogism

    M, (M ==> P) |- P, (Truth:Deduction, Desire:Induction, Occurrence:Derive, Order:ForAllSame)

    M, (P ==> M) |- P, (Truth:Abduction, Desire:Deduction, Occurrence:Derive, Order:ForAllSame)

    M, (S <=> M) |- S, (Truth:Analogy, Desire:Strong, Occurrence:Derive, Order:ForAllSame)

//// conditional composition Comment: Let out for AGI purpose, don't let the system generate conjunctions or useless <=> and ==> statements

//   P, S, no_common_subterm(S,P) |- (S ==> P), (Truth:Induction)
//   P, S, no_common_subterm(S,P) |- (S <=> P), (Truth:Comparison)
//   P, S, no_common_subterm(S,P) |- (P && S), (Truth:Intersection)
//   P, S, no_common_subterm(S,P) |- (P || S), (Truth:Union)

//// propositional decomposition

    S, (&&,S,A_1..n) |- (&&,A_1..n), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame)
    S, (||,S,A_1..n) |- (||,A_1..n), (Truth:DecomposeNegativePositivePositive)

//// multi-conditional syllogism

    ((&&,M,A_1..n) ==> C), M |- ((&&,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)

    ((&&,M,A_1..n) ==> C), ((&&,A_1..n) ==> C) |- M, (Truth:Abduction, Order:ForAllSame)

    ((&&,A_1..n) ==> C), M |- ((&&,M,A_1..n) ==> C), (Truth:Induction, Order:ForAllSame)

    ((&&,M,A_1..n) ==> C), (A ==> M) |- ((&&,A,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)

    ((&&,M,A_1..n) ==> C), ((&&,A,A_1..n) ==> C) |- (A ==> M), (Truth:Abduction, Order:ForAllSame)

    ((&&,A,A_1..n) ==> C), (A ==> M) |- ((&&,M,A_1..n) ==> C), (Truth:Induction, Order:ForAllSame)

//// variable introduction

    (P --> M), (S --> M), not_equal(S,P) |- ((P --> $X) ==> (S --> $X)), (Truth:Abduction),
                                            ((P --> $X) <=> (S --> $X)), (Truth:Comparison),
                                            (&&,(S --> #Y),(P --> #Y)), (Truth:Intersection)

    (P --> M), (S --> M), not_equal(S,P), after((S --> M),(P --> M)) |- ((P --> $X) =/> (S --> $X)), (Truth:Abduction),
                                                                        ((P --> $X) </> (S --> $X)), (Truth:Comparison),
                                                                        (&/,(P --> #Y),(S --> #Y)), (Truth:Intersection)

    (P --> M), (S --> M), not_equal(S,P), concurrent((S --> M),(P --> M)) |- ((P --> $X) =|> (S --> $X)), (Truth:Abduction),
                                                                             ((P --> $X) <|> (S --> $X)), (Truth:Comparison),
                                                                             (&|,(P --> #Y),(S --> #Y)), (Truth:Intersection)

    (M --> P), (M --> S), not_equal(S,P) |- (($X --> S) ==> ($X --> P)), (Truth:Induction),
                                            (($X --> S) <=> ($X --> P)), (Truth:Comparison),
                                            (&&,(#Y --> S),(#Y --> P)), (Truth:Intersection)

    (M --> P), (M --> S), not_equal(S,P), after((M --> P),(M --> S)) |- (($X --> S) =/> ($X --> P)), (Truth:Induction),
                                                                        (($X --> S) </> ($X --> P)), (Truth:Comparison),
                                                                        (&/,(#Y --> S),(#Y --> P)), (Truth:Intersection)

    (M --> P), (M --> S), not_equal(S,P), concurrent((M --> P),(M --> S)) |- (($X --> S) =|> ($X --> P)), (Truth:Induction),
                                                                             (($X --> S) <|> ($X --> P)), (Truth:Comparison),
                                                                             (&|,(#Y --> S),(#Y --> P)), (Truth:Intersection)
//// 2nd variable introduction

    (A ==> (M --> P)), (M --> S), not_equal(A, (M --> S)) |- ((&&,A,($X --> S)) ==> ($X --> P)), (Truth:Induction),
                                                             (&&,(A ==> (#Y --> P)), (#Y --> S)), (Truth:Intersection)

    (&&,(M --> P), A_1..n), (M --> S), not_equal(S,P) |- (($Y --> S) ==> (&&,($Y --> P), A_1..n)), (Truth:Induction),
                                                         (&&,(#Y --> S), (#Y --> P), A_1..n), (Truth:Intersection)

    (A ==> (P --> M)), (S --> M), not_equal(S,P), not_equal(A, (S --> M)) |- ((&&,A,(P --> $X)) ==> (S --> $X)), (Truth:Abduction, Order:Derive),
                                                                             (&&,(A ==> (P --> #Y)), (S --> #Y)), (Truth:Intersection, Order:Derive)

    (&&,(P --> M), A_1..n), (S --> M), not_equal(S,P) |- ((S --> $Y) ==> (&&,(P --> $Y), A_1..n)), (Truth:Abduction),
                                                         (&&, (S --> #Y), (P --> #Y), A_1..n), (Truth:Intersection)

//// dependent variable elimination

    (&&,(#N --> S), A_1..n), (M --> S), substitute(#N,M) |- (&&,A_1..n), (Truth:AnonymousAnalogy)
    (&|,(#N --> S), A_1..n), (M --> S), substitute(#N,M) |- (&|,A_1..n), (Truth:AnonymousAnalogy)
    (&/,(#N --> S), A_1..n), (M --> S), substitute(#N,M) |- (&/,A_1..n), (Truth:AnonymousAnalogy)

    (&&,(S --> #N), A_1..n), (S --> M), substitute(#N,M) |- (&&,A_1..n), (Truth:AnonymousAnalogy)
    (&|,(S --> #N), A_1..n), (S --> M), substitute(#N,M) |- (&|,A_1..n), (Truth:AnonymousAnalogy)
    (&/,(S --> #N), A_1..n), (S --> M), substitute(#N,M) |- (&/,A_1..n), (Truth:AnonymousAnalogy)

//NAL7/8 specific inference

    C, ((&/,C,A_1..n) =\> B) |- ((&/,A_1..n) =\> B), (Truth:Deduction, Occurrence:Derive)
    C, ((&/,C,A_1..n) =/> B) |- ((&/,A_1..n) =/> B), (Truth:Deduction, Occurrence:Derive)
    C, ((&/,C,A_1..n) =|> B) |- ((&/,A_1..n) =|> B), (Truth:Deduction, Occurrence:Derive)
    C, <(&/,C,I) =\> B>, interval(I) |- B, (Truth:Deduction, Desire:Induction, Occurrence:Derive, Event:Anticipate)
    B, <(&/,C,I) =\> B>, interval(I) |- C, (Truth:Abduction, Desire:Induction, Occurrence:Derive, Event:Anticipate)
    C, <(&/,C,I) =/> B>, interval(I) |- B, (Truth:Deduction, Desire:Induction, Occurrence:Derive, Event:Anticipate)
    B, <(&/,C,I) =/> B>, interval(I) |- C, (Truth:Abduction, Desire:Deduction, Occurrence:Derive, Event:Anticipate)
    C, <(&/,C,I) =|> B>, interval(I) |- B, (Truth:Deduction, Desire:Induction, Occurrence:Derive, Event:Anticipate)
    B, <(&/,C,I) =|> B>, interval(I) |- C, (Truth:Abduction, Desire:Deduction, Occurrence:Derive, Event:Anticipate)

//Temporal induction:

    P, S, no_common_subterm(S,P), event(P), event(S), measure_time(S,P,I) |- ((&/,S,I) =/> P), (Truth:Induction),
                                                                             (P =\> (&/,S,I)), (Truth:Induction)
    P, S, no_common_subterm(S,P), event(P), event(S), measure_time(S,P,I) |- ((&/,S,I) </> P), (Truth:Comparison)
    P, S, no_common_subterm(S,P), event(P), event(S), measure_time(S,P,I) |- (&/,S,I,P), (Truth:Intersection)

    P, S, no_common_subterm(S,P), event(P), event(S), concurrent(P,S) |- (S =|> P), (Truth:Induction),
                                                                         (P =|> S), (Truth:Induction)
    P, S, no_common_subterm(S,P), event(P), event(S), concurrent(P,S) |- (S <|> P), (Truth:Comparison)
    P, S, no_common_subterm(S,P), event(P), event(S), concurrent(P,S) |- (&|,S,P), (Truth:Intersection)

////// Theorems in IL:
//TODO
((*,A_1..n) --> M), M |- (A_i --> (/,M, A_1..A_i.substitute(_)..A_n )), (Truth:Identity, Desire:Identity)

////// Truth-value functions
//java./flu


// Utility functions
//java
